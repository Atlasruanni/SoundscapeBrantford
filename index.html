<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoundScape Brantford</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            overflow-x: hidden; 
            background-color: #080808; 
            color: #f5f5f7;
        }
        
        /* Smooth scrolling */
        html { scroll-behavior: smooth; }

        /* Canvas fixed in background */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            outline: none;
            /* CRITICAL: Enable pointer events on the canvas for raycasting */
            pointer-events: auto; 
        }

        /* Overlay content */
        .content-section {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            display: flex;
            align-items: center;
            pointer-events: none;
        }
        
        /* Glass UI */
        .content-box {
            pointer-events: auto;
            background: rgba(18, 18, 20, 0.75);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border-radius: 24px;
            padding: 2.5rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 24px 48px -12px rgba(0,0,0,0.6);
        }

        .scroll-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
            opacity: 0.5;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateX(-50%) translateY(0);}
            40% {transform: translateX(-50%) translateY(-10px);}
            60% {transform: translateX(-50%) translateY(-5px);}
        }

        /* Spec Grid */
        .spec-item {
            background: rgba(255,255,255,0.03);
            padding: 1.25rem;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .loader {
            position: fixed;
            top:0; left:0; width:100%; height:100%;
            background: #080808;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }
        
        .nav-link {
            position: relative;
            color: #888;
            transition: color 0.3s;
        }
        .nav-link:hover { color: #fff; }
    </style>
</head>
<body class="text-slate-200">

    <!-- Loader -->
    <div id="loader" class="loader">
        <div class="flex flex-col items-center">
            <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-r-2 border-yellow-500 mb-4"></div>
            <p class="text-[10px] font-bold tracking-[0.3em] text-zinc-600 uppercase">Generating Geometry</p>
        </div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Navigation -->
    <nav class="fixed top-0 w-full z-50 px-8 py-6 flex justify-between items-center pointer-events-none mix-blend-difference text-white">
        <div class="text-lg font-bold tracking-tighter pointer-events-auto">
            AMBER<span class="text-yellow-400">.LAB</span>
        </div>
        <div class="hidden md:flex gap-8 text-xs font-semibold uppercase tracking-widest pointer-events-auto">
            <a href="#front" class="nav-link">Front</a>
            <a href="#interface" class="nav-link">Interface</a>
            <a href="#details" class="nav-link">Details</a>
            <a href="#specs" class="nav-link">Specs</a>
        </div>
    </nav>

    <!-- Section 1: Front Calibration -->
    <section id="front" class="content-section justify-center text-center px-6">
        <div class="content-box max-w-2xl transform translate-y-32 md:translate-y-48">
            <div class="flex justify-center gap-3 mb-6">
                <span class="bg-yellow-500/20 text-yellow-400 border border-yellow-500/30 px-3 py-1 rounded-full text-[10px] font-bold uppercase tracking-widest">Model 1.9 - Interactive</span>
            </div>
            <h1 class="text-4xl md:text-6xl font-bold mb-4 text-white tracking-tight">
                Reference Precision.
            </h1>
            <p class="text-zinc-400 text-sm md:text-base max-w-md mx-auto leading-relaxed">
                Click the buttons or the center dial to test the embedded functions and interactions.
            </p>
        </div>
        <div class="scroll-indicator text-zinc-600 text-[10px] tracking-[0.2em] uppercase">Scroll to Interact</div>
    </section>

    <!-- Section 2: Interface -->
    <section id="interface" class="content-section justify-start px-6 md:px-24">
        <div class="content-box max-w-sm">
            <h2 class="text-2xl font-bold mb-4 text-white">The Array.</h2>
            <p class="text-zinc-400 text-sm leading-relaxed mb-6">
                The input matrix features a dedicated <strong>Brushed Steel</strong> action key, now matching the tactile feedback of the standard keys.
            </p>
            <div class="flex items-center gap-4 text-xs font-mono text-zinc-500">
                <div class="h-px bg-zinc-700 w-8"></div>
                <span>STEEL_MAT_04</span>
            </div>
        </div>
    </section>

    <!-- Section 3: Dial & Material -->
    <section id="details" class="content-section justify-end px-6 md:px-24">
        <div class="content-box max-w-sm">
            <h2 class="text-2xl font-bold mb-4 text-white">Quad-Section Dial.</h2>
            <p class="text-zinc-400 text-sm leading-relaxed mb-6">
                The center pad toggles its color between Teal and Red, demonstrating a high-priority status function.
            </p>
             <div class="flex items-center gap-4 text-xs font-mono text-zinc-500">
                <div class="h-px bg-zinc-700 w-8"></div>
                <span>CYAN_ACCENT_100</span>
            </div>
        </div>
    </section>

    <!-- Section 4: Specs -->
    <section id="specs" class="content-section min-h-screen items-start justify-center px-6 pt-32">
        <div class="w-full max-w-4xl grid md:grid-cols-3 gap-6">
            <div class="spec-item col-span-1 md:col-span-3 bg-gradient-to-r from-zinc-900 to-zinc-800 border-none">
                <h3 class="text-yellow-400 text-xs font-bold uppercase tracking-widest mb-2">Color Calibration</h3>
                <div class="text-white text-2xl font-mono">PANTONE 123 C</div>
            </div>
            <div class="spec-item">
                <h3 class="text-zinc-500 text-[10px] uppercase tracking-widest mb-2">Dimensions</h3>
                <div class="text-white font-medium">120mm x 52mm</div>
            </div>
            <div class="spec-item">
                <h3 class="text-zinc-500 text-[10px] uppercase tracking-widest mb-2">Material</h3>
                <div class="text-white font-medium">Polycarbonate</div>
            </div>
            <div class="spec-item">
                <h3 class="text-zinc-500 text-[10px] uppercase tracking-widest mb-2">Interface</h3>
                <div class="text-white font-medium">Hybrid Tactile</div>
            </div>
        </div>
    </section>

    <script>
    // WRAPPED IN IIFE TO PREVENT VARIABLE REDECLARATION ERRORS
    (function() {
        // --- SCENE CONFIGURATION ---
        const container = document.getElementById('canvas-container');
        // Clear previous canvas if re-running
        if(container.firstChild) {
            container.removeChild(container.firstChild);
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x080808); 

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        // Initial "Front" view for 1:1 match
        camera.position.set(0, 0, 10); 
        
        const renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);
        
        // --- INTERACTIVITY SETUP ---
        let raycaster, mouse;
        let clickableObjects = []; // Array to store meshes that can be clicked

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();


        // --- LIGHTING (Studio High Contrast) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);

        // Main Key Light
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(5, 5, 10);
        mainLight.castShadow = true;
        mainLight.shadow.bias = -0.0001;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        // Rim Light (Top)
        const topLight = new THREE.SpotLight(0xffffff, 2.0);
        topLight.position.set(0, 10, 0);
        topLight.lookAt(0,0,0);
        scene.add(topLight);

        // Fill Light (Warmth for the yellow)
        const fillLight = new THREE.PointLight(0xffaa00, 0.3);
        fillLight.position.set(-5, 0, 5);
        scene.add(fillLight);

        // --- MATERIALS ---
        
        // 1. EXACT YELLOW BODY
        const colorYellow = 0xFFB800; 
        const matBody = new THREE.MeshPhysicalMaterial({
            color: colorYellow,
            roughness: 0.25,
            metalness: 0.05,
            clearcoat: 0.2,
            clearcoatRoughness: 0.1
        });

        // 2. MATTE BLACK
        const matBlack = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.8,
            metalness: 0.1
        });

        // 3. TURQUOISE CENTER (DEFAULT)
        const colorCyan = 0x00E5C0; // Vibrant Teal
        const matCyan = new THREE.MeshPhysicalMaterial({
            color: colorCyan,
            roughness: 0.3,
            metalness: 0.0,
            emissive: colorCyan,
            emissiveIntensity: 0.1
        });
        
        // 4. ALTERNATE DIAL COLOR (Red/Pink)
        const colorRed = 0xFF0055;
        const matRedDial = new THREE.MeshPhysicalMaterial({
            color: colorRed,
            roughness: 0.3,
            metalness: 0.0,
            emissive: colorRed,
            emissiveIntensity: 0.1
        });

        // 5. BRUSHED STEEL
        const matSteel = new THREE.MeshStandardMaterial({
            color: 0xE0E0E0,
            roughness: 0.35,
            metalness: 0.9,
        });
        
        // 6. RED INDICATOR LED
        const matRedLED = new THREE.MeshBasicMaterial({
            color: 0xFF0000,
        });
        
        // 7. BUTTON PRESS COLOR (Temporary)
        const matGrayPress = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            roughness: 0.8,
            metalness: 0.1
        });

        // --- GEOMETRY HELPERS ---
        function createRoundedRect(w, h, r) {
            const shape = new THREE.Shape();
            shape.moveTo(-w/2 + r, h/2);
            shape.lineTo(w/2 - r, h/2);
            shape.quadraticCurveTo(w/2, h/2, w/2, h/2 - r);
            shape.lineTo(w/2, -h/2 + r);
            shape.quadraticCurveTo(w/2, -h/2, w/2 - r, -h/2);
            shape.lineTo(-w/2 + r, -h/2);
            shape.quadraticCurveTo(-w/2, -h/2, -w/2, -h/2 + r);
            shape.lineTo(-w/2, h/2 - r);
            shape.quadraticCurveTo(-w/2, h/2, -w/2 + r, h/2);
            return shape;
        }

        // --- BUILD DEVICE ---
        const deviceGroup = new THREE.Group();

        // 1. CHASSIS
        const chassisHeight = 2.2;
        const chassisWidth = 5.3;
        const chassisDepth = 0.6;
        const chassisRadius = 0.55; 

        const chassisShape = createRoundedRect(chassisWidth, chassisHeight, chassisRadius);
        const chassisGeo = new THREE.ExtrudeGeometry(chassisShape, {
            depth: chassisDepth,
            bevelEnabled: true,
            bevelThickness: 0.08,
            bevelSize: 0.08,
            bevelSegments: 6
        });
        chassisGeo.center();
        const chassis = new THREE.Mesh(chassisGeo, matBody);
        deviceGroup.add(chassis);

        const Z_SURFACE = (chassisDepth/2) + 0.08; // Front face Z

        // 2. LEFT DIAL (With Quadrant Detail)
        const dialGroup = new THREE.Group();
        dialGroup.position.set(-1.45, 0, Z_SURFACE);

        // A. Outer Dish (Black)
        const DIAL_SIZE = 1.8;
        const dishGeo = new THREE.CylinderGeometry(DIAL_SIZE/2, DIAL_SIZE/2 + 0.1, 0.15, 64);
        const dish = new THREE.Mesh(dishGeo, matBlack);
        dish.rotation.x = Math.PI/2;
        dish.position.z = -0.05;
        dialGroup.add(dish);

        // B. Inner Concave Slope
        const slopeGeo = new THREE.CylinderGeometry(DIAL_SIZE/3.2, DIAL_SIZE/2, 0.2, 64, 1, true);
        const slope = new THREE.Mesh(slopeGeo, matBlack);
        slope.rotation.x = Math.PI/2;
        slope.position.z = 0.0;
        dialGroup.add(slope);

        // C. Quadrant Markers (The "Cross" lines)
        const markerGeo = new THREE.BoxGeometry(0.04, DIAL_SIZE/2 - DIAL_SIZE/3.2, 0.05);
        for(let i=0; i<4; i++) {
            const m = new THREE.Mesh(markerGeo, matBlack);
            const angle = (i * 90) * (Math.PI/180);
            const radius = (DIAL_SIZE/2 + DIAL_SIZE/3.2) / 2;
            m.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 0.05);
            m.rotation.z = angle;
            dialGroup.add(m);
        }

        // D. Teal Center Button (Clickable)
        const btnGeo = new THREE.CylinderGeometry(DIAL_SIZE/3.3, DIAL_SIZE/3.3, 0.1, 64);
        const btn = new THREE.Mesh(btnGeo, matCyan);
        btn.rotation.x = Math.PI/2;
        btn.position.z = 0.02;
        btn.name = 'DIAL_CENTER'; // Add name for raycasting
        dialGroup.add(btn);
        clickableObjects.push(btn); // Add to clickable list

        deviceGroup.add(dialGroup);

        // 3. CENTER SPEAKER ARRAY
        const SPK_W = 1.1;
        const SPK_H = 1.5;
        
        // Texture Generation
        const cvs = document.createElement('canvas');
        cvs.width = 512; cvs.height = 512;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#FFB800'; 
        ctx.fillRect(0,0,512,512);
        ctx.fillStyle = '#221100'; // Dark recessed color
        const gridX = 14;
        const gridY = 18;
        const pad = 30;
        const stepX = (512 - pad*2) / gridX;
        const stepY = (512 - pad*2) / gridY;

        for(let y=0; y<=gridY; y++) {
            for(let x=0; x<=gridX; x++) {
                ctx.beginPath();
                ctx.arc(pad + x*stepX, pad + y*stepY, 8, 0, Math.PI*2);
                ctx.fill();
            }
        }
        const spkTex = new THREE.CanvasTexture(cvs);
        const matSpk = new THREE.MeshPhysicalMaterial({
            map: spkTex,
            color: 0xFFB800,
            roughness: 0.4
        });
        const spkPlane = new THREE.Mesh(new THREE.PlaneGeometry(SPK_W, SPK_H), matSpk);
        spkPlane.position.set(0.1, 0, Z_SURFACE + 0.01);
        deviceGroup.add(spkPlane);

        // 4. RIGHT BUTTON CLUSTER
        const padGroup = new THREE.Group();
        padGroup.position.set(1.65, 0, Z_SURFACE);

        // A. Housing (Rounded Rect)
        const HS_SIZE = 1.8; 
        const hsShape = createRoundedRect(HS_SIZE, HS_SIZE, 0.25);
        const hsGeo = new THREE.ExtrudeGeometry(hsShape, { depth: 0.1, bevelEnabled: false});
        hsGeo.center();
        const hs = new THREE.Mesh(hsGeo, matBlack);
        hs.position.z = 0.02;
        padGroup.add(hs);

        // B. Buttons (4x Grid)
        const gap = 0.08;
        const btnDim = (HS_SIZE - (gap*3)) / 2;
        
        // Button Shape
        const btnShape = createRoundedRect(btnDim, btnDim, 0.12);
        const btnGeom = new THREE.ExtrudeGeometry(btnShape, {
            depth: 0.15,
            bevelEnabled: true,
            bevelSize: 0.03,
            bevelThickness: 0.03
        });
        btnGeom.center();

        const positions = [
            { x: -btnDim/2 - gap/2, y: btnDim/2 + gap/2, mat: matBlack, name: 'BUTTON_TL', originalMat: matBlack }, // TL
            { x: btnDim/2 + gap/2, y: btnDim/2 + gap/2, mat: matBlack, name: 'BUTTON_TR', originalMat: matBlack },  // TR
            { x: -btnDim/2 - gap/2, y: -btnDim/2 - gap/2, mat: matBlack, name: 'BUTTON_BL', originalMat: matBlack },// BL
            { x: btnDim/2 + gap/2, y: -btnDim/2 - gap/2, mat: matSteel, name: 'ACTION_BUTTON', originalMat: matSteel }  // BR (Steel)
        ];

        positions.forEach((p) => {
            const b = new THREE.Mesh(btnGeom, p.mat);
            b.position.set(p.x, p.y, 0.08);
            b.name = p.name;
            b.userData.originalMat = p.originalMat; // Store original material reference
            
            // Add Red Dot to last button (BR)
            if(p.name === 'ACTION_BUTTON') {
                const dGeo = new THREE.CircleGeometry(0.04, 16);
                const dMat = matRedLED;
                const dot = new THREE.Mesh(dGeo, dMat);
                // Position in top-right corner of the button
                dot.position.set(btnDim/3, -btnDim/3, 0.08); 
                b.add(dot);
            }
            padGroup.add(b);
            clickableObjects.push(b); // Add to clickable list
        });

        deviceGroup.add(padGroup);

        scene.add(deviceGroup);

        // --- INTERACTION LOGIC ---
        function onPointerDown(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(clickableObjects, false);

            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Visual Feedback: Button Press Animation
                const originalZ = intersected.position.z;
                const originalScale = intersected.scale.clone();
                intersected.position.z -= 0.02; // Press in slightly
                intersected.scale.set(0.98, 0.98, 0.98); // Shrink slightly

                setTimeout(() => {
                    // Release animation
                    intersected.position.z = originalZ;
                    intersected.scale.copy(originalScale);
                    // Also reset temporary press color
                    if (intersected.name.startsWith('BUTTON') || intersected.name === 'ACTION_BUTTON') {
                        intersected.material = intersected.userData.originalMat;
                    }
                }, 150);

                console.log('Button clicked:', intersected.name);

                // --- DEMONSTRATE FUNCTIONALITY ---
                if (intersected.name === 'DIAL_CENTER') {
                    // Center Dial (Teal) Toggles its color
                    const dialCenter = scene.getObjectByName('DIAL_CENTER');
                    if (dialCenter) {
                        // Check against the hex value to avoid material object mismatch issues
                        if (dialCenter.material.color.getHex() === matCyan.color.getHex()) {
                            dialCenter.material = matRedDial;
                            console.log('Dial Center: Color changed to Red (Status Toggled).');
                        } else {
                            dialCenter.material = matCyan;
                            console.log('Dial Center: Color changed back to Teal (Status Toggled).');
                        }
                    }
                } else if (intersected.name === 'ACTION_BUTTON') {
                    // ACTION BUTTON: Simple visual feedback (same as black buttons)
                    intersected.material = matGrayPress;
                    console.log('Action Button: Simple press acknowledged.');
                } else if (intersected.name.startsWith('BUTTON')) {
                    // Simple visual feedback for black buttons
                    intersected.material = matGrayPress;
                }
            }
        }

        container.addEventListener('pointerdown', onPointerDown, false);

        // --- ANIMATION / SCROLL LOGIC ---
        
        // Defines camera and object targets for each section
        const targets = {
            'front': { 
                cam: {x:0, y:-0.8, z:8.5}, // Camera moved down more to shift object higher
                rot: {x:0, y:0, z:0} 
            },
            'interface': { 
                cam: {x:0.5, y:0, z:5}, // Camera moved further left to shift object more right
                rot: {x:0, y:0.25, z:0} // Slight turn to see buttons
            },
            'details': { 
                cam: {x:-0.5, y:0, z:5}, // Camera moved further right to shift object more left
                rot: {x:0, y:-0.25, z:0} // Slight turn to see dial
            },
            'specs': { 
                cam: {x:0, y:1.2, z:7}, // Camera lowered to reveal bottom edge
                rot: {x:THREE.MathUtils.degToRad(-90), y:0, z:0} // Rotate -90 degrees around X-axis (Dial faces top)
            }
        };

        let currentSection = 'front';

        function updateScroll() {
            const sections = ['front', 'interface', 'details', 'specs'];
            let bestMatch = sections[0];
            let maxVis = 0;

            sections.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                const rect = el.getBoundingClientRect();
                // Simple visibility check
                const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                if (visibleHeight > maxVis) {
                    maxVis = visibleHeight;
                    bestMatch = id;
                }
            });
            currentSection = bestMatch;
        }

        window.addEventListener('scroll', updateScroll);

        function animate() {
            requestAnimationFrame(animate);

            const tgt = targets[currentSection];
            if(tgt) {
                // Smooth Camera Interp
                camera.position.x += (tgt.cam.x - camera.position.x) * 0.05;
                camera.position.y += (tgt.cam.y - camera.position.y) * 0.05;
                camera.position.z += (tgt.cam.z - camera.position.z) * 0.05;

                // Smooth Object Rotation
                deviceGroup.rotation.x += (tgt.rot.x - deviceGroup.rotation.x) * 0.05;
                deviceGroup.rotation.y += (tgt.rot.y - deviceGroup.rotation.y) * 0.05;
                deviceGroup.rotation.z += (tgt.rot.z - deviceGroup.rotation.z) * 0.05;
            }

            // Idle Float
            const time = Date.now() * 0.001;
            deviceGroup.position.y = Math.sin(time) * 0.05;

            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- INIT ---
        window.onload = () => {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.opacity = 0;
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 500);
            }
            animate();
        };

    })(); // End IIFE
    </script>
</body>
</html>
