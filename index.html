<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoundScape Brantford</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            overflow-x: hidden; 
            background-color: #080808; 
            color: #f5f5f7;
        }
        
        /* Smooth scrolling */
        html { scroll-behavior: smooth; }

        /* Canvas fixed in background */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            outline: none;
            /* CRITICAL: Enable pointer events on the canvas for raycasting */
            pointer-events: auto; 
        }

        /* Overlay content */
        .content-section {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            display: flex;
            align-items: center;
            pointer-events: none;
        }
        
        /* Glass UI */
        .content-box {
            pointer-events: auto;
            background: rgba(18, 18, 20, 0.75);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border-radius: 24px;
            padding: 2.5rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 24px 48px -12px rgba(0,0,0,0.6);
        }

        .scroll-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
            opacity: 0.5;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateX(-50%) translateY(0);}
            40% {transform: translateX(-50%) translateY(-10px);}
            60% {transform: translateX(-50%) translateY(-5px);}
        }

        /* Spec Grid */
        .spec-item {
            background: rgba(255,255,255,0.03);
            padding: 1.25rem;
            border-radius: 12px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .loader {
            position: fixed;
            top:0; left:0; width:100%; height:100%;
            background: #080808;
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }
        
        .nav-link {
            position: relative;
            color: #888;
            transition: color 0.3s;
        }
        .nav-link:hover { color: #fff; }
    </style>
</head>
<body class="text-slate-200">

    <!-- Loader -->
    <div id="loader" class="loader">
        <div class="flex flex-col items-center">
            <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-r-2 border-yellow-500 mb-4"></div>
            <p class="text-[10px] font-bold tracking-[0.3em] text-zinc-600 uppercase">Generating Geometry</p>
        </div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Navigation -->
    <nav class="fixed top-0 w-full z-50 px-8 py-6 flex justify-between items-center pointer-events-none mix-blend-difference text-white">
        <div class="text-lg font-bold tracking-tighter pointer-events-auto">
            AMBER<span class="text-yellow-400">.LAB</span>
        </div>
        <div class="hidden md:flex gap-8 text-xs font-semibold uppercase tracking-widest pointer-events-auto">
            <a href="#front" class="nav-link">Front</a>
            <a href="#interface" class="nav-link">Interface</a>
            <a href="#details" class="nav-link">Details</a>
            <a href="#specs" class="nav-link">Specs</a>
        </div>
    </nav>

    <!-- Section 1: Front Calibration -->
    <section id="front" class="content-section justify-center text-center px-6">
        <div class="content-box max-w-2xl transform translate-y-32 md:translate-y-48">
            <div class="flex justify-center gap-3 mb-6">
                <span class="bg-yellow-500/20 text-yellow-400 border border-yellow-500/30 px-3 py-1 rounded-full text-[10px] font-bold uppercase tracking-widest">Model 1.9 - Interactive</span>
            </div>
            <h1 class="text-4xl md:text-6xl font-bold mb-4 text-white tracking-tight">
                Reference Precision.
            </h1>
            <p class="text-zinc-400 text-sm md:text-base max-w-md mx-auto leading-relaxed">
                Click the buttons or the center dial to test the embedded functions and interactions.
            </p>
        </div>
        <div class="scroll-indicator text-zinc-600 text-[0.2em] uppercase">Scroll to Interact</div>
    </section>

    <!-- Section 2: Interface -->
    <section id="interface" class="content-section justify-start px-6 md:px-24">
        <div class="content-box max-w-sm">
            <h2 class="text-2xl font-bold mb-4 text-white">The Array.</h2>
            <p class="text-zinc-400 text-sm leading-relaxed mb-6">
                The input matrix features a dedicated <strong>Brushed Steel</strong> action key, now matching the tactile feedback of the standard keys.
            </p>
            <div class="flex items-center gap-4 text-xs font-mono text-zinc-500">
                <div class="h-px bg-zinc-700 w-8"></div>
                <span>STEEL_MAT_04</span>
            </div>
        </div>
    </section>

    <!-- Section 3: Dial & Material -->
    <section id="details" class="content-section justify-end px-6 md:px-24">
        <div class="content-box max-w-sm">
            <h2 class="text-2xl font-bold mb-4 text-white">Quad-Section Dial.</h2>
            <p class="text-zinc-400 text-sm leading-relaxed mb-6">
                The center pad toggles its color between Teal and Red, demonstrating a high-priority status function.
            </p>
             <div class="flex items-center gap-4 text-xs font-mono text-zinc-500">
                <div class="h-px bg-zinc-700 w-8"></div>
                <span>CYAN_ACCENT_100</span>
            </div>
        </div>
    </section>

    <!-- Section 4: Specs -->
    <section id="specs" class="content-section min-h-screen items-start justify-center px-6 pt-32">
        <div class="w-full max-w-4xl grid md:grid-cols-3 gap-6">
            <div class="spec-item col-span-1 md:col-span-3 bg-gradient-to-r from-zinc-900 to-zinc-800 border-none">
                <h3 class="text-yellow-400 text-xs font-bold uppercase tracking-widest mb-2">Color Calibration</h3>
                <div class="text-white text-2xl font-mono">PANTONE 123 C</div>
            </div>
            <div class="spec-item">
                <h3 class="text-zinc-500 text-[10px] uppercase tracking-widest mb-2">Dimensions</h3>
                <!-- NOTE: The physical dimensions displayed here (120mm x 52mm) 
                     are placeholders and do not reflect the current Three.js unit size (5.75 x 2.2). -->
                <div class="text-white font-medium">120mm x 52mm</div> 
            </div>
            <div class="spec-item">
                <h3 class="text-zinc-500 text-[10px] uppercase tracking-widest mb-2">Material</h3>
                <div class="text-white font-medium">Polycarbonate</div>
            </div>
            <div class="spec-item">
                <h3 class="text-zinc-500 text-[10px] uppercase tracking-widest mb-2">Interface</h3>
                <div class="text-white font-medium">Hybrid Tactile</div>
            </div>
        </div>
    </section>

    <script>
    // WRAPPED IN IIFE TO PREVENT VARIABLE REDECLARATION ERRORS
    (function() {
        // --- SCENE CONFIGURATION ---
        const container = document.getElementById('canvas-container');
        // Clear previous canvas if re-running
        if(container.firstChild) {
            container.removeChild(container.firstChild);
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x080808); 

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        // Initial "Front" view for 1:1 match
        camera.position.set(0, 0, 10); 
        
        const renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);
        
        // --- INTERACTIVITY SETUP ---
        let raycaster, mouse;
        let clickableObjects = []; // Array to store meshes that can be clicked
        let redDotLED = null; // Global reference for the red dot mesh

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();


        // --- LIGHTING (Studio High Contrast) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);

        // Main Key Light
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(5, 5, 10);
        mainLight.castShadow = true;
        mainLight.shadow.bias = -0.0001;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        // Rim Light (Top)
        const topLight = new THREE.SpotLight(0xffffff, 2.0);
        topLight.position.set(0, 10, 0);
        topLight.lookAt(0,0,0);
        scene.add(topLight);

        // Fill Light (Warmth for the yellow)
        const fillLight = new THREE.PointLight(0xffaa00, 0.3);
        fillLight.position.set(-5, 0, 5);
        scene.add(fillLight);

        // --- MATERIALS ---
        
        // 1. EXACT YELLOW BODY
        const colorYellow = 0xFFB800; 
        const matBody = new THREE.MeshPhysicalMaterial({
            color: colorYellow,
            roughness: 0.25,
            metalness: 0.05,
            clearcoat: 0.2,
            clearcoatRoughness: 0.1
        });

        // 2. MATTE BLACK
        const matBlack = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.8,
            metalness: 0.1
        });

        // 3. TURQUOISE CENTER (DEFAULT)
        const colorCyan = 0x00E5C0; // Vibrant Teal
        const matCyan = new THREE.MeshPhysicalMaterial({
            color: colorCyan,
            roughness: 0.3,
            metalness: 0.0,
            emissive: colorCyan,
            emissiveIntensity: 0.1
        });
        
        // 4. ALTERNATE DIAL COLOR (Red/Pink)
        const colorRed = 0xFF0055;
        const matRedDial = new THREE.MeshPhysicalMaterial({
            color: colorRed,
            roughness: 0.3,
            metalness: 0.0,
            emissive: colorRed,
            emissiveIntensity: 0.1
        });

        // 5. BRUSHED STEEL (MODIFIED: Darker Grey)
        const matSteel = new THREE.MeshStandardMaterial({
            color: 0x9E9E9E, // Changed from 0xE0E0E0 to darker grey
            roughness: 0.35,
            metalness: 0.9,
        });
        
        // 6. RED INDICATOR LED (ON state)
        const matRedLED = new THREE.MeshBasicMaterial({
            color: 0xFF0000,
            // Use Emissive to make it glow slightly, matching the teal dial
            emissive: 0xFF0000, 
            emissiveIntensity: 0.5
        });

        // 8. BLACK INDICATOR LED (OFF state - new default for the dot)
        const matBlackDot = new THREE.MeshBasicMaterial({
            color: 0x000000,
        });
        
        // 7. BUTTON PRESS COLOR (Temporary)
        const matGrayPress = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa,
            roughness: 0.8,
            metalness: 0.1
        });

        // --- GEOMETRY HELPERS ---
        function createRoundedRect(w, h, r) {
            const shape = new THREE.Shape();
            shape.moveTo(-w/2 + r, h/2);
            shape.lineTo(w/2 - r, h/2);
            shape.quadraticCurveTo(w/2, h/2, w/2, h/2 - r);
            shape.lineTo(w/2, -h/2 + r);
            shape.quadraticCurveTo(w/2, -h/2, w/2 - r, -h/2);
            shape.lineTo(-w/2 + r, -h/2);
            shape.quadraticCurveTo(-w/2, -h/2, -w/2, -h/2 + r);
            shape.lineTo(-w/2, h/2 - r);
            shape.quadraticCurveTo(-w/2, h/2, -w/2 + r, h/2);
            return shape;
        }

        // --- BUILD DEVICE ---
        const deviceGroup = new THREE.Group();

        // 1. CHASSIS
        const chassisHeight = 2.2;
        const chassisWidth = 5.75;
        const chassisDepth = 0.6;
        const chassisRadius = 0.55; 

        const chassisShape = createRoundedRect(chassisWidth, chassisHeight, chassisRadius);
        const chassisGeo = new THREE.ExtrudeGeometry(chassisShape, {
            depth: chassisDepth,
            bevelEnabled: true,
            bevelThickness: 0.08,
            bevelSize: 0.08,
            bevelSegments: 6
        });
        chassisGeo.center();
        const chassis = new THREE.Mesh(chassisGeo, matBody);
        deviceGroup.add(chassis);

        const Z_SURFACE = (chassisDepth/2) + 0.08; // Front face Z

        // 2. LEFT DIAL (With Quadrant Detail)
        const dialGroup = new THREE.Group();
        // Position is -1.75
        dialGroup.position.set(-1.75, 0, Z_SURFACE);

        // A. Outer Dish (Black)
        const DIAL_SIZE = 1.8;
        const dishGeo = new THREE.CylinderGeometry(DIAL_SIZE/2, DIAL_SIZE/2 + 0.1, 0.15, 64);
        const dish = new THREE.Mesh(dishGeo, matBlack);
        dish.rotation.x = Math.PI/2;
        dish.position.z = -0.05;
        dialGroup.add(dish);

        // B. Inner Concave Slope
        const slopeGeo = new THREE.CylinderGeometry(DIAL_SIZE/3.2, DIAL_SIZE/2, 0.2, 64, 1, true);
        const slope = new THREE.Mesh(slopeGeo, matBlack);
        slope.rotation.x = Math.PI/2;
        slope.position.z = 0.0;
        dialGroup.add(slope);

        // C. Quadrant Markers (The "Cross" lines) - Removed
        /*
        const markerGeo = new THREE.BoxGeometry(0.04, DIAL_SIZE/2 - DIAL_SIZE/3.2, 0.05);
        for(let i=0; i<4; i++) {
            const m = new THREE.Mesh(markerGeo, matBlack);
            const angle = (i * 90) * (Math.PI/180);
            const radius = (DIAL_SIZE/2 + DIAL_SIZE/3.2) / 2;
            m.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 0.05);
            m.rotation.z = angle;
            dialGroup.add(m);
        }
        */

        // D. Teal Center Button (Clickable)
        const btnGeo = new THREE.CylinderGeometry(DIAL_SIZE/3.3, DIAL_SIZE/3.3, 0.1, 64);
        const btn = new THREE.Mesh(btnGeo, matCyan);
        btn.rotation.x = Math.PI/2;
        btn.position.z = 0.02;
        btn.name = 'DIAL_CENTER'; // Add name for raycasting
        dialGroup.add(btn);
        clickableObjects.push(btn); // Add to clickable list

        deviceGroup.add(dialGroup);

        // 3. CENTER SPEAKER ARRAY
        // Grille dimensions to visually fit the 1:2 aspect ratio
        const SPK_W = 1.0; 
        const SPK_H = 1.8;
        
        // Texture Generation
        const cvs = document.createElement('canvas');
        // Canvas dimensions matching desired visual aspect ratio for better texture mapping
        cvs.width = 256; 
        cvs.height = 512; // Double the height for 1:2 ratio
        const ctx = cvs.getContext('2d');
        // The background is left transparent to show the yellow chassis below
        
        // Draw dark holes
        ctx.fillStyle = '#000000'; // Pure black for the holes
        
        // Grid configuration for staggered circular pattern (9 then 10)
        const gridY = 20; // 21 rows total (0 to 20)
        const radius = 7; 
        const padX = 10; // REDUCED PADDING for density
        const padY = 10; // REDUCED PADDING for density
        const stepY = (cvs.height - padY*2) / gridY; // Vertical step remains constant

        const drawableWidth = cvs.width - padX * 2;
        
        // Base horizontal spacing determined by the row with more dots (10 dots = 9 intervals)
        const baseStepX = drawableWidth / (10 - 1); // 10 dots is the widest row

        for(let y=0; y<=gridY; y++) {
            // Rows 0, 2, 4, ... 20 have 9 dots (8 intervals)
            // Rows 1, 3, 5, ... 19 have 10 dots (9 intervals)
            const numDots = (y % 2 === 0) ? 9 : 10; 
            
            // Calculate the total width spanned by the dots in this row (based on consistent spacing)
            const rowWidth = baseStepX * (numDots - 1);
            
            // Calculate the horizontal offset needed to center the row.
            const centeringOffset = (drawableWidth - rowWidth) / 2;

            for(let x=0; x<numDots; x++) {
                const dotX = padX + centeringOffset + x * baseStepX;
                
                ctx.beginPath();
                ctx.arc(dotX, padY + y*stepY, radius, 0, Math.PI*2);
                ctx.fill();
            }
        }

        const spkTex = new THREE.CanvasTexture(cvs);
        // Ensure texture wrapping is set to repeat for tiling if necessary (though centered plane is better)
        spkTex.wrapS = spkTex.wrapT = THREE.ClampToEdgeWrapping; 
        
        const matSpk = new THREE.MeshPhysicalMaterial({
            map: spkTex,
            color: 0x000000, // Color of the material is technically black, but only where the texture is drawn.
            roughness: 0.4,
            transparent: true, // IMPORTANT: Enable transparency
            alphaTest: 0.1 // IMPORTANT: Cut out transparent parts
        });
        const spkPlane = new THREE.Mesh(new THREE.PlaneGeometry(SPK_W, SPK_H), matSpk);
        // Position is -0.1
        spkPlane.position.set(-0.21, 0, Z_SURFACE + 0.01); 
        deviceGroup.add(spkPlane);

        // 4. RIGHT BUTTON CLUSTER
        const padGroup = new THREE.Group();
        // Position is 1.55
        padGroup.position.set(1.55, 0, Z_SURFACE); 

        // A. Housing (Rounded Rect)
        const HS_H = 1.74; // Housing Height is fixed
        const HS_W = 2.24; // Housing Width is fixed
        
        const hsShape = createRoundedRect(HS_W, HS_H, 0.25);
        const hsGeo = new THREE.ExtrudeGeometry(hsShape, { depth: 0.05, bevelEnabled: false}); // Housing depth 0.05
        hsGeo.center();
        const hs = new THREE.Mesh(hsGeo, matBlack);
        hs.position.z = 0.02;
        padGroup.add(hs);

        // B. Buttons (4x Grid)
        // Note: The 'gap' variable is retained for the bevel logic, but gaps are dynamically calculated
        // based on the fixed housing size and new button dimensions.
        const gap = 0.08; 
        
        // Button dimensions: W = 0.88, H = 0.66
        const btnDimW = 0.88; 
        const btnDimH = 0.66; 
        
        // New Gaps based on fixed housing (HS_W=2.24, HS_H=1.74)
        const gapX = (HS_W - 2 * btnDimW) / 3; // 0.16
        const gapY = (HS_H - 2 * btnDimH) / 3; // 0.14

        // Button Shape using new dimensions
        const btnShape = createRoundedRect(btnDimW, btnDimH, 0.12);
        const btnGeom = new THREE.ExtrudeGeometry(btnShape, {
            depth: 0.02, // CONFIRMED: depth 0.02
            bevelEnabled: true,
            bevelSize: 0.03,
            bevelThickness: 0.03
        });
        btnGeom.center();

        // Calculate positions based on new gaps and dimensions
        // X position for right buttons: (btnDimW/2) + (gapX/2)
        // X position for left buttons: -(btnDimW/2) - (gapX/2)
        const X_OFFSET = (btnDimW / 2) + (gapX / 2);
        const Y_OFFSET = (btnDimH / 2) + (gapY / 2);

        // New Z position for the buttons (slight raise above the Z=0.02 housing pad)
        const BUTTON_Z_POS = 0.04; // CONFIRMED: 0.04

        const positions = [
            { x: -X_OFFSET, y: Y_OFFSET, mat: matBlack, name: 'BUTTON_TL', originalMat: matBlack }, // TL
            { x: X_OFFSET, y: Y_OFFSET, mat: matBlack, name: 'BUTTON_TR', originalMat: matBlack },  // TR
            { x: -X_OFFSET, y: -Y_OFFSET, mat: matBlack, name: 'BUTTON_BL', originalMat: matBlack },// BL
            { x: X_OFFSET, y: -Y_OFFSET, mat: matSteel, name: 'ACTION_BUTTON', originalMat: matSteel }  // BR (Steel)
        ];

        positions.forEach((p) => {
            const b = new THREE.Mesh(btnGeom, p.mat);
            b.position.set(p.x, p.y, BUTTON_Z_POS); // Z position
            b.name = p.name;
            b.userData.originalMat = p.originalMat; // Store original material reference
            
            // Add Red Dot to last button (BR)
            if(p.name === 'ACTION_BUTTON') {
                const dGeo = new THREE.CircleGeometry(0.04, 16);
                const dMat = matBlackDot; // MODIFIED: Start as black (off)
                const dot = new THREE.Mesh(dGeo, dMat);
                
                // Position in top-right corner of the button
                // Z position for the dot
                dot.position.set(btnDimW/3, -btnDimH/3, BUTTON_Z_POS); 
                b.add(dot);
                redDotLED = dot; // Store global reference
            }
            padGroup.add(b);
            clickableObjects.push(b); // Add to clickable list
        });

        deviceGroup.add(padGroup);

        scene.add(deviceGroup);

        // --- INTERACTION LOGIC ---
        function onPointerDown(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(clickableObjects, false);

            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                
                // Visual Feedback: Button Press Animation
                const originalZ = intersected.position.z;
                const originalScale = intersected.scale.clone();
                // Since the dot is a child of the button, it moves along with the button's position.
                intersected.position.z -= 0.01; // Press in slightly
                intersected.scale.set(0.98, 0.98, 0.98); // Shrink slightly

                setTimeout(() => {
                    // Release animation
                    intersected.position.z = originalZ;
                    intersected.scale.copy(originalScale);
                    // Also reset temporary press color
                    if (intersected.name.startsWith('BUTTON') || intersected.name === 'ACTION_BUTTON') {
                        intersected.material = intersected.userData.originalMat;
                    }
                }, 150);

                console.log('Button clicked:', intersected.name);

                // --- DEMONSTRATE FUNCTIONALITY ---
                if (intersected.name === 'DIAL_CENTER') {
                    // Center Dial (Teal) Toggles its color
                    const dialCenter = scene.getObjectByName('DIAL_CENTER');
                    if (dialCenter) {
                        // Check against the hex value to avoid material object mismatch issues
                        if (dialCenter.material.color.getHex() === matCyan.color.getHex()) {
                            dialCenter.material = matRedDial;
                            console.log('Dial Center: Color changed to Red (Status Toggled).');
                        } else {
                            dialCenter.material = matCyan;
                            console.log('Dial Center: Color changed back to Teal (Status Toggled).');
                        }
                    }
                } else if (intersected.name === 'ACTION_BUTTON') {
                    // ACTION BUTTON: Simple visual feedback (same as black buttons)
                    intersected.material = matGrayPress;
                    
                    if (redDotLED) {
                        // Toggle LED between red (ON) and black (OFF)
                        if (redDotLED.material.color.getHex() === matBlackDot.color.getHex()) {
                            redDotLED.material = matRedLED;
                            console.log('Action Button: LED ON.');
                        } else {
                            redDotLED.material = matBlackDot;
                            console.log('Action Button: LED OFF.');
                        }
                    }
                    console.log('Action Button: Simple press acknowledged.');
                } else if (intersected.name.startsWith('BUTTON')) {
                    // Simple visual feedback for black buttons
                    intersected.material = matGrayPress;
                }
            }
        }

        container.addEventListener('pointerdown', onPointerDown, false);

        // --- ANIMATION / SCROLL LOGIC ---
        
        // Defines camera and object targets for each section
        const targets = {
            'front': { 
                cam: {x:0, y:-0.8, z:8.5}, // Camera moved down more to shift object higher
                rot: {x:0, y:0, z:0} 
            },
            'interface': { 
                cam: {x:0.5, y:0, z:5}, // Camera moved further left to shift object more right
                rot: {x:0, y:0.25, z:0} // Slight turn to see buttons
            },
            'details': { 
                cam: {x:-0.5, y:0, z:5}, // Camera moved further right to shift object more left
                rot: {x:0, y:-0.25, z:0} // Slight turn to see dial
            },
            'specs': { 
                cam: {x:0, y:1.2, z:7}, // Camera lowered to reveal bottom edge
                rot: {x:THREE.MathUtils.degToRad(-90), y:0, z:0} // Rotate -90 degrees around X-axis (Dial faces top)
            }
        };

        let currentSection = 'front';

        function updateScroll() {
            const sections = ['front', 'interface', 'details', 'specs'];
            let bestMatch = sections[0];
            let maxVis = 0;

            sections.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                const rect = el.getBoundingClientRect();
                // Simple visibility check
                const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                if (visibleHeight > maxVis) {
                    maxVis = visibleHeight;
                    bestMatch = id;
                }
            });
            currentSection = bestMatch;
        }

        window.addEventListener('scroll', updateScroll);

        function animate() {
            requestAnimationFrame(animate);

            const tgt = targets[currentSection];
            if(tgt) {
                // Smooth Camera Interp
                camera.position.x += (tgt.cam.x - camera.position.x) * 0.05;
                camera.position.y += (tgt.cam.y - camera.position.y) * 0.05;
                camera.position.z += (tgt.cam.z - camera.position.z) * 0.05;

                // Smooth Object Rotation
                deviceGroup.rotation.x += (tgt.rot.x - deviceGroup.rotation.x) * 0.05;
                deviceGroup.rotation.y += (tgt.rot.y - deviceGroup.rotation.y) * 0.05;
                deviceGroup.rotation.z += (tgt.rot.z - deviceGroup.rotation.z) * 0.05;
            }

            // Idle Float
            const time = Date.now() * 0.001;
            deviceGroup.position.y = Math.sin(time) * 0.05;

            renderer.render(scene, camera);
        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- INIT ---
        window.onload = () => {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.style.opacity = 0;
                setTimeout(() => {
                    loader.style.display = 'none';
                }, 500);
            }
            animate();
        };

    })(); // End IIFE
    </script>
</body>
</html>
